一个引用的生命周期，一定不会超过其被引用的时间。这显而易见的，为了防止悬垂引用
如果存在一个值的可变借用，那么在该借用作用域内，不允许有其它引用(读或写)
没有可变借用的情况下，允许存在多个对同一值的不可变借用


```rust
fn main(){
    let mut a = String::from("hello");
	let a_ref = &mut a;
	println!("a is {}", a);// compile error 因为在 a_ref 最后调用之间
	a_ref.push('!');
}
```

我一开始困惑的点在于，这个作用域到底有多大！！！远古版本是词法作用域，后来改进了，变成第一次借用开始，直到最后一次调用结束，这样作用域小很多

a_ref.push('!');
println!("a is {}", a);


struct Stu{
  Age: int32
  Name: &str
}

这里面 Name 是一个字符串的引用，所以实例化的 Stu 对象没有 Name 的所有权，那么就要符合上面的借用规则。说白了，就是内存谁负责释放的问题

还有一个是类型的方法，第一个参数要写成 &self 或是 &mut self, 如果写成 self 那么函数就会捕捉类型的所有权，函数执行一次，就无法再使用这个类型
